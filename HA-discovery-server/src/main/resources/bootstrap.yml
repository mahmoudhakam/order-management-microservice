cluster:
  node1:
    hostname: eureka-peer1
    port: 8761
  node2:
    hostname: eureka-peer2
    port: 8762
  node3:
    hostname: eureka-peer3
    port: 8763

enableSwagger: true

app:
  eureka:
    user: appusr
    pass: appdev

spring:
  application.name: discovery-server

server:
  port: 8761

eureka:
  environment: Development
  datacenter: On Premise
  instance:
    hostname: localhost
    lease-renewal-interval-in-seconds: 30
    appname: eureka-cluster
  client:
    # for development set it to false in order to not register itself to its peer.
    register-with-eureka: false #Do you register yourself with Eureka Server?
    fetch-registry: false #Do not get registration information through eureka
    service-url.defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
  server:
    # Make the number of renewals required to prevent an emergency tiny (probably 0)
#    renewal-percent-threshold: 0.49

#    response-cache-update-interval-ms: 5000
    # Switch off self-preservation. Will turn lease expiration on and evict all instances which
    #  no longer sent a heartbeat and whose lease has expired.
    # Self-preservation is desirable for Eureka clusters and where network outages
    #  (e.g. between data centers) could be possible.
    # Note: the lease validity / expiration is configured in the Eureka _client_ instances
    # (see eureka.instance.lease-expiration-duration-in-seconds).
#    enable-self-preservation: true

    # Make sure this is set to the same value as the lease renewal interval in
    #  Eureka _client_ instances (or slightly higher), This value is relevant for Eureka's
    #  calculation of the 'current renewal threshold'.
    # Specifically, the following equation is used:
    #  current renewal threshold = (60s / expected-client-renewal-interval-seconds) *
    #  renewal-percent-threshold * current number of client instances.
    # In this case:
    # - for one registered client: 60 / 3 * 0.5 * 1 = 10.
    # - for two registered clients: 60 / 3 * 0,5 * 2 = 20.
    # As soon as two clients are connected:
#    expected-client-renewal-interval-seconds: 3

    # The interval in which the instance eviction task scans for instances with expired leases.
    # Given in milliseconds.
#    eviction-interval-timer-in-ms: 2000
#    wait-time-in-ms-when-sync-empty: 0

logging.level:
  com.netflix:
    eureka: DEBUG
    discovery: DEBUG

---
spring.profiles: node1

server:
  port: ${cluster.node1.port}

eureka:
  instance:
    hostname: ${cluster.node1.hostname} #eurekaInstance Name
  client:
    register-with-eureka: true #Do you register yourself with Eureka Server?
    fetch-registry: true #Do not get registration information through eureka
    service-url.defaultZone: "${EUREKA_CLUSTER_ZONE:http://${cluster.node2.hostname}:${cluster.node2.port}/eureka/,http://${cluster.node3.hostname}:${cluster.node3.port}/eureka/}"

---
spring.profiles: node2

server:
  port: ${cluster.node2.port}

eureka:
  instance:
    hostname: ${cluster.node2.hostname} #eurekaInstance Name
  client:
    register-with-eureka: true #Do you register yourself with Eureka Server?
    fetch-registry: true #Do not get registration information through eureka
    service-url.defaultZone: "${EUREKA_CLUSTER_ZONE:http://${cluster.node1.hostname}:${cluster.node1.port}/eureka/,http://${cluster.node3.hostname}:${cluster.node3.port}/eureka/}"
---
spring.profiles: node3

server:
  port: ${cluster.node3.port}

eureka:
  instance:
    hostname: ${cluster.node3.hostname} #eurekaInstance Name
  client:
    register-with-eureka: true #Do you register yourself with Eureka Server?
    fetch-registry: true #Do not get registration information through eureka
    service-url.defaultZone: "${EUREKA_CLUSTER_ZONE:http://${cluster.node1.hostname}:${cluster.node1.port}/eureka/,http://${cluster.node2.hostname}:${cluster.node2.port}/eureka/}"
